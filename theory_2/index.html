<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../img/favicon.ico" />
    <title>Theory of spin dynamics - II - MuSpinSim Documentation</title>
    <link rel="stylesheet" href="../css/theme.css" />
    <link rel="stylesheet" href="../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "Theory of spin dynamics - II";
        var mkdocs_page_input_path = "theory_2.md";
        var mkdocs_page_url = null;
      </script>
    
    <script src="../js/jquery-3.6.0.min.js" defer></script>
    <!--[if lt IE 9]>
      <script src="../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
      <script>hljs.initHighlightingOnLoad();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href=".." class="icon icon-home"> MuSpinSim Documentation
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="..">Welcome to MuSpinSim's documentation</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../installation/">Installation</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../theory_1/">Theory of spin dynamics - I</a>
                </li>
              </ul>
              <ul class="current">
                <li class="toctree-l1 current"><a class="reference internal current" href="./">Theory of spin dynamics - II</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#preparing-the-initial-state">Preparing the initial state</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#time-evolution">Time evolution</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#closed-system">Closed system</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#a-faster-method">A faster method</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#celios-method">Celio's Method</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#integral-of-asymmetry">Integral of asymmetry</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#open-systems">Open systems</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#the-lindblad-master-equation">The Lindblad Master Equation</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#a-simple-example">A simple example</a>
    </li>
        </ul>
    </li>
    </ul>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../hamiltonian/">Hamiltonian</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../tutorial/">Tutorial</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../input/">Input</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../examples/">Examples</a>
                </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="..">MuSpinSim Documentation</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href=".." class="icon icon-home" alt="Docs"></a> &raquo;</li>
      <li>Theory of spin dynamics - II</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="theory-of-spin-dynamics-ii">Theory of spin dynamics - II</h1>
<h2 id="preparing-the-initial-state">Preparing the initial state</h2>
<p>When performing a simulation of a muon experiment, the first step is to prepare the system in an appropriate quantum state to evolve under the Hamiltonian. MuSpinSim uses the following rules to prepare this state:</p>
<ul>
<li>the muon is prepared in a state polarised along the direction of the beam (conventionally, the <em>x</em> axis in the laboratory frame of reference);</li>
<li>every other spin is prepared in a thermal density matrix state.</li>
</ul>
<p>A thermal density matrix state simply means a state in which every energy level is populated with a probability following the Boltzmann distribution, and fully decohered otherwise. In other words:</p>
<div class="arithmatex">\[
    \rho_{th}(T) = \frac{e^{-\frac{\mathcal{H}}{k_BT}}}{\mathrm{Tr}\left(e^{-\frac{\mathcal{H}}{k_BT}}\right)}
\]</div>
<p>where the trace below is the partition function of the system. 
One can see how finding this matrix would in principle require diagonalising the Hamiltonian of the whole system the muon is being inserted in. In practice, in MuSpinSim we use one of two approximations:</p>
<ul>
<li>by default, the <span class="arithmatex">\(T=\infty\)</span> approximation is used, in which all states are equally populated. The advantage of this approximation is that it's completely invariant to any change of basis - it doesn't make a difference what exactly the eigenstates of the Hamiltonian are. The real temperature of the sample, of course, is not infinite, but as long as <span class="arithmatex">\(k_BT \gg \mathcal{H}\)</span>, that's a fair enough approximation;</li>
<li>if requested by the user, finite temperature can be used, but the Hamiltonian is simplified to the Zeeman Hamiltonian, <span class="arithmatex">\(\mathcal{H} \approx \hbar \sum_i\gamma_i \mathbf{B}\mathbf{S}^{(i)}\)</span>.  This approximation keeps all spins independent from each other, ignoring their possible couplings, and is very effective in the case in which a strong magnetic field is applied and the Zeeman term is prevalent in the Hamiltonian. It should not be used for zero field experiment simulations.</li>
</ul>
<blockquote>
<p><strong>For developers:</strong> the initial density matrix is calculated in the property <code>.rho0()</code> of the class <code>ExperimentRunner</code>, found in <code>muspinsim/experiment.py</code>.</p>
</blockquote>
<h2 id="time-evolution">Time evolution</h2>
<h3 id="closed-system">Closed system</h3>
<p>Time evolution for the density matrix of a closed quantum system is controlled by the Liouville-von Neumann equation that we've already seen:</p>
<div class="arithmatex">\[
\frac{\partial \rho}{\partial t} = -\frac{i}{\hbar}[\mathcal{H}, \rho]
\]</div>
<p>If we write the matrix quantities with indices (repeated indices imply summation) we can write this as a system of coupled differential equations for each individual coefficient:</p>
<div class="arithmatex">\[
\frac{\partial \rho_{ij}}{\partial t} = -\frac{i}{\hbar}\left(\mathcal{H}_{ik}\rho_{kj}-\rho_{ik}\mathcal{H}_{kj}\right)
\]</div>
<p>This gets significantly simpler when we express both the matrices in a basis in which the Hamiltonian is diagonal, and thus <span class="arithmatex">\(\mathcal{H}_{ij} = \lambda_i\delta_{ij}\)</span>:</p>
<div class="arithmatex">\[
\frac{\partial \rho_{ij}}{\partial t} = -\frac{i}{\hbar}\rho_{ij}\left(\lambda_i-\lambda_j\right) 
\qquad
\implies
\qquad
\rho_{ij}(t) = e^{-\frac{i}{\hbar}\left(\lambda_i-\lambda_j\right) t}\rho_{ij}(0)
\]</div>
<p>This way we can see that the equations are completely decoupled. Coefficients on the diagonal of the density matrix don't change, while off-diagonal coefficients gain a phase factor at a constant rate that is dependent on the differences between the Hamiltonian eigenvalues. This method gives us the exact evolution of the system and perfectly preserves unitarity. The downside of it is that it requires a full diagonalization of the Hamiltonian. However, many spin systems that we are interested in are relatively small, and one single diagonalisation for each of them isn't a big deal. For a cheaper, more approximate method see <a href="#celios-method">Celio's Method</a>.</p>
<blockquote>
<p><strong>For developers:</strong> time evolution of a system is handled by the <code>.evolve()</code> method of the <code>Hamiltonian</code> class.</p>
</blockquote>
<h4 id="a-faster-method">A faster method</h4>
<p>When simulating systems where <span class="arithmatex">\(\frac{B}{T} \rightarrow 0\)</span>, i.e. when we have zero external magnetic field or the temperature <span class="arithmatex">\(T \rightarrow \infty\)</span>, MuSpinSim will automatically employ a faster method of time evolution. To explain this method we first note that the density matrix at <span class="arithmatex">\(t=0\)</span> for the muon polarised along a direction <span class="arithmatex">\({\hat n}\)</span> can be written as</p>
<div class="arithmatex">\[
 \rho_\mu (t=0) = \frac{1}{2}(\mathbb{1} + \sigma_\mu^{\hat n}),
\]</div>
<p>and hence the density matrix of the full system is, (defining <span class="arithmatex">\(d =\prod_{i \neq 0} 2I_i + 1\)</span> as the dimension of the Hilbert space without the muon)</p>
<div class="arithmatex">\[
 \rho(t=0) = \frac{1}{2}(\mathbb{1}+\sigma_\mu^{\hat n}) \otimes \frac{1}{d}\mathbb{1}_d.
\]</div>
<p>Here we want to calculate the time dependence of the muon polarisation along <span class="arithmatex">\({\hat n}\)</span>, which is given by (notational abuse 
means <span class="arithmatex">\(\sigma_\mu^{\hat n}(t) = e^{-\frac{i}{\hbar}Ht}(\sigma_\mu^{\hat n} \otimes \mathbb{1}_d) e^{\frac{i}{\hbar}Ht}\)</span>)</p>
<div class="arithmatex">\[
 P^{\hat n}_\mu(t) = \mathrm{Tr}[\rho(t)\sigma_\mu^{\hat n}(0)] = \mathrm{Tr}[\rho(t=0)\sigma_\mu^{\hat n}(t)].
\]</div>
<p>We have also switched which operator we are time-evolving on the RHS here. Now, substituting <span class="arithmatex">\(\rho(t=0)\)</span>,  we get</p>
<div class="arithmatex">\[
P^{\hat n}_\mu(t) = \mathrm{Tr}[\rho(t=0)\sigma_\mu^{\hat n}(t)]= \mathrm{Tr}\Bigg[\Big(\frac{1}{2}(\mathbb{1}+\sigma_\mu^{\hat n}) \otimes \frac{1}{d}\mathbb{1}_{d} \Big)\sigma_\mu^{\hat n}(t)\Bigg] 
\]</div>
<p>which can be simplified to</p>
<div class="arithmatex">\[
P^{\hat n}_\mu(t) = \frac{1}{2d}\mathrm{Tr}\Bigg[\Big((\mathbb{1}+\sigma_\mu^{\hat n}) \otimes \mathbb{1}_{d} \Big)\sigma_\mu^{\hat n}(t)\Bigg].
\]</div>
<p>Now, if we factor out the first term in the trace, we get</p>
<div class="arithmatex">\[
P^{\hat n}_\mu(t) = \frac{1}{2d}\mathrm{Tr}[(\mathbb{1} \otimes \mathbb{1}_{d}) \sigma_\mu^{\hat n}(t)]
            +\frac{1}{2d}\mathrm{Tr}\Bigg[(\sigma_\mu^{\hat n} \otimes \mathbb{1}_{d}) \sigma_\mu^{\hat n}(t)\Bigg].
\]</div>
<p>Note that ass the trace of a Pauli spin matrix is <strong>always</strong> zero, only the second term is non-zero. Hence the muon polarisation can be written 
as (after re-defining <span class="arithmatex">\(\sigma_\mu^{\hat n}\)</span> to include the kronecker product with the identity matrix of the other spins)</p>
<div class="arithmatex">\[
P^{\hat n}_\mu(t) = \frac{1}{2d}\mathrm{Tr}\Bigg[\sigma_\mu^{\hat n}(0) \sigma_\mu^{\hat n}(t)\Bigg].
\]</div>
<p>Now replacing the trace with <span class="arithmatex">\(\sum_\alpha \langle \alpha| ... | \alpha \rangle\)</span>, where <span class="arithmatex">\(| \alpha \rangle\)</span> is a complete set 
of orthonormal eigenstates we obtain</p>
<div class="arithmatex">\[
P^{\hat n}_\mu(t) = \frac{1}{2d}\sum_\alpha \langle \alpha | \Bigg[\sigma_\mu^{\hat n}(0) \sigma_\mu^{\hat n}(t)\Bigg] | \alpha \rangle.
\]</div>
<p>Explicitly writing out the time dependance, we get</p>
<div class="arithmatex">\[
P^{\hat n}_\mu(t) = \frac{1}{2d}\sum_{\alpha, \beta, \gamma} \langle \alpha | \sigma_\mu^{\hat n}(0) |\beta \rangle e^{iE_\beta t} \langle \beta | \sigma_\mu^{\hat n}(0)
|\gamma \rangle e^{-iE_\gamma t} \langle \gamma | \alpha \rangle,
\]</div>
<p>and as <span class="arithmatex">\(\langle \gamma | \alpha \rangle = \delta_{\gamma, \alpha}\)</span>, this simplifies to</p>
<div class="arithmatex">\[
P^{\hat n}_\mu(t) = \frac{1}{2d}\sum_{\alpha, \beta} \langle \alpha | \sigma_\mu^{\hat n}(0) |\beta \rangle e^{iE_\beta t} \langle \beta | \sigma_\mu^{\hat n}(0)
|\alpha \rangle e^{-iE_\alpha t},
\]</div>
<p>so that</p>
<div class="arithmatex">\[
P^{\hat n}_\mu(t) = \frac{1}{2d}\sum_{\alpha, \beta} \Big| \langle \alpha | \sigma_\mu^{\hat n}(0) |\beta \rangle \Big|^2 e^{i(E_\beta-E_\alpha) t}.
\]</div>
<p>Then, we can separate these terms into</p>
<div class="arithmatex">\[
\begin{aligned}
P^{\hat n}_\mu(t) &amp; = \frac{1}{2d}\sum_{\alpha = \beta} \Big| \langle \alpha | \sigma_\mu^{\hat n}(0) |\beta \rangle \Big|^2 e^{i(E_\beta-E_\alpha) t} \\
&amp; + \frac{1}{2d}\sum_{\alpha &lt; \beta} \Big| \langle \alpha | \sigma_\mu^{\hat n}(0) |\beta \rangle \Big|^2 e^{i(E_\beta-E_\alpha) t} + \frac{1}{2d}\sum_{\alpha &gt; \beta} \Big| \langle \alpha | \sigma_\mu^{\hat n}(0) |\beta \rangle \Big|^2 e^{i(E_\beta-E_\alpha) t}.
\end{aligned}
\]</div>
<p>Now by swapping <span class="arithmatex">\(\alpha\)</span> and <span class="arithmatex">\(\beta\)</span> in the last term, we see that it is the same as the second term apart from a sign in the exponential, so they may combined to give</p>
<div class="arithmatex">\[
P^{\hat n}_\mu(t) = \frac{1}{2d}\sum_{\alpha = \beta} \Big| \langle \alpha | \sigma_\mu^{\hat n}(0) |\beta \rangle \Big|^2 e^{i(E_\beta-E_\alpha) t} + \frac{1}{2d}\sum_{\alpha &lt; \beta} \Big| \langle \alpha | \sigma_\mu^{\hat n}(0) |\beta \rangle \Big|^2 [e^{i(E_\beta-E_\alpha) t} + e^{-i(E_\beta-E_\alpha) t}].
\]</div>
<p>Finally, by expressing the exponentials in terms of <span class="arithmatex">\(\sin\)</span> and <span class="arithmatex">\(\cos\)</span>, we may simplify the expression to</p>
<div class="arithmatex">\[
P^{\hat n}_\mu(t) = \frac{1}{2d}\sum_{\alpha = \beta}\Big|\langle\alpha|\sigma_{\mu}^{\hat{n}}|\beta\rangle\Big|^2 + \frac{1}{d}\sum_{\alpha &lt; \beta} \Big| \langle \alpha | \sigma_\mu^{\hat n}(0) |\beta \rangle \Big|^2 \cos [(E_\beta-E_\alpha) t].
\]</div>
<p>When installed with OpenMP, MuSpinSim will parallelise this method over the time values, so when computing for 100 times, it will run on up to 100 threads.</p>
<blockquote>
<p><strong>For developers:</strong> this time evolution of a system is handled by the <code>.fast_evolve()</code> method of the <code>Hamiltonian</code> class.</p>
</blockquote>
<h4 id="celios-method">Celio's Method</h4>
<p>MuSpinSim can also make use of an approximation to speedup calculations and reduce memory usage in certain cases using <a href="https://www.doi.org/10.1103/PhysRevLett.56.2720">Celio's method</a>. To do this we first split up the Hamiltonian into contributions from each interaction.</p>
<div class="arithmatex">\[
H = \sum_{i}^{N} H_i
\]</div>
<p>Then referring back to the earlier result</p>
<div class="arithmatex">\[
\rho(t) = e^{-\frac{i}{\hbar}Ht}\rho(0)e^{\frac{i}{\hbar}Ht}.
\]</div>
<p>We expand using the Suzuki–Trotter formula</p>
<div class="arithmatex">\[
e^{H_1 + H_2} = \lim_{k\rightarrow\infty}{\left[e^{\frac{H_1}{k}}e^{\frac{H_2}{k}}\right]^k}
\]</div>
<p>To obtain</p>
<div class="arithmatex">\[
e^{-\frac{i}{\hbar}Ht} = \lim_{k\rightarrow\infty}{\left[\prod_{i}^{N}e^{-\frac{i}{k\hbar}H_it}\right]^k}
\]</div>
<p>This allows us to compute the evolution operator while avoiding the diagonalisation of the Hamiltonian. In reality this formula is a simplification as each <span class="arithmatex">\(H_i\)</span> acts in a smaller subspace of dimension determined by the spins involved in the interaction it describes. As a result, in computing this product in terms of matrices, we must also do the kronecker product with identity matrices that match the dimensions of the other particles in the system. We also use swap gates to ensure the order of these kronecker products is preserved.</p>
<p>As an example, taking system of a muon and two electrons (labelled 1, 2 and 3 respectively) with a single dipolar interaction defined between the muon and second electron we compute</p>
<div class="arithmatex">\[
e^{-\frac{i}{\hbar}Ht} = \lim_{k\rightarrow\infty}{\left[\text{SWAP}_{32} \left( \mathbb{1}_2 \otimes e^{-\frac{i}{k\hbar}H_{13}t}\right)\right]^k}
\]</div>
<p>Where <span class="arithmatex">\(H_{12}\)</span> is the contribution from the dipolar interaction and <span class="arithmatex">\(\mathbb{1}_2\)</span> is the identity matrix of size <span class="arithmatex">\(2I + 1 = 2\)</span> (For the first electron). <span class="arithmatex">\(\text{SWAP}_{32}\)</span> is a swap gate that has the effect of reversing the kronecker products into the correct order and is required since <span class="arithmatex">\(H_{13}\)</span> is formed in a subspace with only particles 1 and 3 whereas it should be computed for the system with particles 1, 2 and 3 in that order.</p>
<p>Due to the extra matrix products this method is most suitable when the evolution operator's matrix is sparse for which it will be faster and will use significantly less memory. This will generally be the case for larger spins with a few simple interactions. MuSpinSim will log a warning in its output if the sparsity doesn't appear suitable for this variant Celio's method.</p>
<h5 id="further-speedup">Further speedup</h5>
<p>For a further speedup we can continue to follow Celio's method, approximating the initial state of the system provided that <span class="arithmatex">\(T\rightarrow \infty\)</span> and use this to provide a large increase in performance. This method is also less susceptible to matrices becoming dense allowing the evolution of more complex systems but with a lower accuracy.</p>
<p>Here instead of evolving the density matrix, we instead evolve <span class="arithmatex">\(\sigma_{\mu}=2I_{\mu}\)</span> which are the Pauli matrices in the direction of the muon.</p>
<div class="arithmatex">\[
\sigma_{\mu}(t) = e^{-\frac{i}{\hbar}Ht}\sigma_{\mu}e^{\frac{i}{\hbar}Ht}
\]</div>
<p>Then by choosing a representation where <span class="arithmatex">\(\sigma_{\mu}\)</span> is diagonal we can write the muon polarisation as</p>
<div class="arithmatex">\[
P(t) = \sum_{n=1}^{d}{w_n\bra{\psi_n(t)}\sigma_{\mu}\ket{\psi_n(t)}}
\]</div>
<p>where d is the total dimension of the system and</p>
<div class="arithmatex">\[
\ket{\psi_n(t)} = e^{\frac{-iHt}{\hbar}}\ket{\psi_n(0)}
\]</div>
<p>gives the time evolution of the initial approximated states.</p>
<p>The coefficients <span class="arithmatex">\(w_n\)</span> here describe the probability of finding the spin system in the state <span class="arithmatex">\(\ket{\psi_n(0)}\)</span> at <span class="arithmatex">\(t = 0\)</span>. In standard experimental conditions these are determined as</p>
<div class="arithmatex">\[
w_n = \frac{2}{d}\text{  if  }\sigma_{\mu}\ket{\psi_n(0)} = + \ket{\psi_n(0)} 
\]</div>
<div class="arithmatex">\[
w_n = 0\text{  if  }\sigma_{\mu}\ket{\psi_n(0)} = - \ket{\psi_n(0)} 
\]</div>
<p>Thus we can diagonalise the density matrix for the muon given by</p>
<div class="arithmatex">\[
\rho = \mathbb{1}_2 + \sigma_{\mu}
\]</div>
<p>and choose the eigenvector with a positive eigenvalue to obtain the initial state <span class="arithmatex">\(\ket{\psi(0)}\)</span></p>
<p>Now we define the total initial state of the system as</p>
<div class="arithmatex">\[
\ket{\phi(0)} = \sum_{m=1}^{d/2}\left(\frac{2}{d}\right)^{1/2}e^{i\lambda_m}\ket{\psi_m(0)}
\]</div>
<p>where <span class="arithmatex">\(\lambda_m\)</span> is chosen randomly in the range <span class="arithmatex">\([0, 2\pi]\)</span>.</p>
<p>Then the state at a later time t is given by</p>
<div class="arithmatex">\[
\ket{\phi(t)} = \sum_{m=1}^{d/2}\left(\frac{2}{d}\right)^{1/2}e^{i\lambda_m}\ket{\psi_m(t)}
\]</div>
<p>and the matrix elements are given by</p>
<div class="arithmatex">\[
\bra{\phi(t)}\sigma_{\mu}\ket{\phi(t)} = \sum_{m=1}^{d/2}\frac{2}{d}\bra{\psi_m(t)}\sigma_{\mu}\ket{\psi_m(t)} + \sum_{m,n=1, m\neq n}^{d/2}\frac{2}{d}e^{i(\lambda_m - \lambda_n)}\bra{\psi_n(t)}\sigma_{\mu}\ket{\psi_m(t)}
\]</div>
<p>This second term vanishes for very large <span class="arithmatex">\(d\)</span> allowing us to avoid very large matrix products which speeds up the method drastically. When installed with OpenMP, MuSpinSim will parallelise this method over the values of <span class="arithmatex">\(m\)</span>.</p>
<blockquote>
<p><strong>For developers:</strong> time evolution of a system using Celio's method is handled by the <code>.evolve()</code> and <code>.fast_evolve()</code> methods of the <code>CelioHamiltonian</code> class.</p>
</blockquote>
<h3 id="integral-of-asymmetry">Integral of asymmetry</h3>
<p>In muon experiments we're usually interested in measuring the asymmetry of positron hits between the forward and back detectors in the experimental setup - namely, the polarisation of the muon along a certain axis, as it evolves in time. However, in some cases (like ALC experiments) what we actually care about is the <em>integral</em> of this asymmetry throughout a certain time interval. This could be trivially computed simply by computing the time evolution and then integrating numerically. However MuSpinSim in this case uses a different algorithm to perform the integral analytically, saving some unnecessary steps. The full derivation of the formula is detailed in <a href="https://arxiv.org/abs/1704.02785">this arXiv paper</a>. The essence of it is that, if we have an operator <span class="arithmatex">\(S\)</span> with matrix elements <span class="arithmatex">\(s_{ij}\)</span> whose integral value we want to compute:</p>
<p>$$
\langle P \rangle = \int_0^\infty \langle S \rangle(t) e^{-\frac{t}{\tau}} dt
$$
where the integral is weighed with the decay process of the muon with lifetime <span class="arithmatex">\(\tau\)</span>, then we can define a new operator <span class="arithmatex">\(P\)</span> with matrix elements:</p>
<div class="arithmatex">\[
p_{ij} = \frac{s_{ij}}{\frac{1}{\tau}-\frac{i}{\hbar}\left(\lambda_i-\lambda_j\right)}
\]</div>
<p>and evaluating its expectation value on the initial state of the system will in a single pass return the value of the desired integral.</p>
<blockquote>
<p><strong>For developers:</strong> integral expectation values are handled by the <code>.integrate_decaying()</code> method of the <code>Hamiltonian</code> class.</p>
</blockquote>
<h2 id="open-systems">Open systems</h2>
<h3 id="the-lindblad-master-equation">The Lindblad Master Equation</h3>
<p>Systems described by the Liouville-von Neumann equation are closed; they conserve energy and evolve in a perfectly reversible way. This is sometimes not a good approximation, because in real life, the chunk of the sample that we're describing is of course only a small part of a much bigger system, fully coupled to it and interacting in a lot of ways. Since including an environment of hundreds or thousands of spins is not practical, a more common approach is to use a <em>master equation</em> that allows to describe irreversible evolution through some kind of energy exchange with environmental degrees of freedom.
In MuSpinSim, the only such master equation that is supported is the simplest one, the Lindblad equation. It is an extension of the Liouville-von Neumann equation including dissipative terms:</p>
<div class="arithmatex">\[
\frac{\partial \rho}{\partial t} = -\frac{i}{\hbar}[\mathcal{H}, \rho] + \sum_{i=1}^{N^2-1}\alpha_i\left(L_i \rho L_i^\dagger - \frac{1}{2}\left\{L_i^\dagger L_i, \rho\right\} \right)
\]</div>
<p>Here the <span class="arithmatex">\(\alpha_i\)</span> are coefficients that express the strength of the coupling with a certain degree of freedom, and the <span class="arithmatex">\(L_i\)</span> are the so-called Lindblad or jump operators of the system, each connected to one coefficient. The curly braces denote the <em>anticommutator</em> of two matrices: <span class="arithmatex">\(\{A, B\} = AB+BA\)</span>.</p>
<p>This equation unfortunately does not have a neat solution in exponential form as the one seen above in the matrix formalism. It is however possible to find something very close to it by making a few small changes in the representation, namely, expressing the density matrix in what is called the <em>Fock-Liouville space</em>. An excellent and detailed explanation of this technique is given in this <a href="https://arxiv.org/abs/1906.04478">useful introductory paper by Daniel Manzano</a>. The essence of it is that we "straighten up" the density matrix, writing all its elements in a single column vector. For example, a <span class="arithmatex">\(4\times 4\)</span> matrix can turn into a <span class="arithmatex">\(16\)</span> elements column vector. It is then possible to write a matrix called the Lindbladian (that in the example will be <span class="arithmatex">\(16 \times 16\)</span>) that operates on it exactly like a Hamiltonian does on a single wavefunction:</p>
<div class="arithmatex">\[
\frac{\partial}{\partial t} \mid \rho \rangle\rangle = \mathcal{L} \mid \rho \rangle\rangle
\]</div>
<p>and following from that, it is possible to integrate the equations as trivially as seen for the others by diagonalising the Lindbladian. Care must be taken though because unlike for the Hamiltonian, there is no guarantee that the Lindbladian is Hermitian, or for that matter, diagonalizable at all! This can potentially cause issues - however in my experience well-defined systems will be solvable without problems.</p>
<p>In MuSpinSim, the only way dissipation can be included in a calculation is by putting an individual spin in contact with a thermal reserve. This is done by defining two jump operators for that spin, <span class="arithmatex">\(S_+^i\)</span> and <span class="arithmatex">\(S_-^i\)</span>, and the corresponding dissipation coefficients such that</p>
<div class="arithmatex">\[
\frac{\alpha_+^i}{\alpha_-^i} = \exp\left(-\frac{\hbar\gamma |B|}{k_BT}\right)
\]</div>
<p>where <span class="arithmatex">\(T\)</span> is the temperature of the system, and <span class="arithmatex">\(\hbar\gamma|B|\)</span> is an approximation using only the Zeeman interaction of the energy gap between successive states of the spin. For <span class="arithmatex">\(T &lt; \infty\)</span>, this is subject to the same limits as the choice of using only the Zeeman interaction to define the initial thermal state density matrix. In fact, the effect of these terms is to tend to drive the individual spin's state towards exactly that thermal state, adding or removing energy as needed and erasing coherences.</p>
<blockquote>
<p><strong>For developers:</strong> the <code>Lindbladian</code> class is defined in <code>muspinsim/lindbladian.py</code>. It has <code>.evolve()</code> and <code>.integrate_decaying()</code> methods analogous to those of the <code>Hamiltonian</code> class.</p>
</blockquote>
<h3 id="a-simple-example">A simple example</h3>
<p>Let's look at a basic example of a problem that can be solved analytically with the Lindblad master equation to see how it works. Let's consider a single muon immersed in a magnetic field <span class="arithmatex">\(B\)</span> such that it has Larmor frequency <span class="arithmatex">\(\omega_L = \gamma_\mu B\)</span>. It is prepared in a state polarised along <span class="arithmatex">\(x\)</span>, so the initial density matrix is</p>
<div class="arithmatex">\[
\rho_0 = \begin{bmatrix}
\frac{1}{2} &amp; \frac{1}{2} \\
\frac{1}{2} &amp; \frac{1}{2}
\end{bmatrix}
\]</div>
<p>and is coupled to an environment with infinite temperature (so <span class="arithmatex">\(\alpha_+ = \alpha_- = \alpha\)</span>). The Hamiltonian for this system will then be:</p>
<div class="arithmatex">\[
\mathcal{H} = \hbar \omega_L S_z
\]</div>
<p>and the jump operators are </p>
<div class="arithmatex">\[
S_+ = \begin{bmatrix}
0 &amp; 1 \\
0 &amp; 0
\end{bmatrix}
\qquad
S_- = \begin{bmatrix}
0 &amp; 0 \\
1 &amp; 0
\end{bmatrix}.
\]</div>
<p>Let's write the Lindblad master equation in full:</p>
<div class="arithmatex">\[
\begin{align*}
\frac{\partial \rho}{\partial t} = &amp;i\omega_L(\rho S_z-S_z\rho) + \\
&amp; \alpha\left(S_+ \rho S_- + S_- \rho S_+ - \frac{1}{2}S_+S_-\rho - \frac{1}{2} S_-S_+\rho - \frac{1}{2} \rho S_+S_- - \frac{1}{2} \rho S_-S_+ \right)
\end{align*}
\]</div>
<p>where we made use of the fact that <span class="arithmatex">\(S_+^\dagger = S_-\)</span> and vice versa. If we write <span class="arithmatex">\(\rho\)</span> in terms of its components and expand the products, keeping in mind that it has to be Hermitian, we get:</p>
<div class="arithmatex">\[
\frac{\partial}{\partial t}\begin{bmatrix}
\rho_{11} &amp; \rho_{12} \\
\rho_{12}^* &amp; \rho_{22}
\end{bmatrix} = 
i \omega_L \begin{bmatrix}
0 &amp; -r_{12} \\
r_{12}^* &amp; 0
\end{bmatrix}
+\alpha
\left(
\begin{bmatrix}
\rho_{22} &amp; 0 \\
0 &amp; \rho_{11}
\end{bmatrix}
- \begin{bmatrix}
\rho_{11} &amp; \rho_{12} \\
\rho_{12}^* &amp; \rho_{22}
\end{bmatrix}
\right)
\]</div>
<p>We can then expand this in three differential equations (we leave out the fourth one as it's just the complex conjugate of one of the others):</p>
<div class="arithmatex">\[
\begin{align*}
\frac{\partial \rho_{11}}{\partial t} = &amp; \alpha(\rho_{22}-\rho_{11}) \\
\frac{\partial \rho_{22}}{\partial t} = &amp; \alpha(\rho_{11}-\rho_{22}) \\
\frac{\partial \rho_{12}}{\partial t} = &amp; -i\omega_L \rho_{12} -\alpha\rho_{12}
\end{align*}
\]</div>
<p>which combined with the initial conditions from the starting density matrix lead to the solutions:</p>
<div class="arithmatex">\[
\begin{align*}
\rho_{11}(t) = &amp; \rho_{22}(t) = \frac{1}{2} \\
\rho_{12}(t) = &amp; \frac{1}{2}e^{-i\omega_Lt -\alpha t}
\end{align*}
\]</div>
<p>In other words, the evolution has an oscillating phase on the off-diagonal elements plus an exponential decay which brings them down to zero, as the interactions with the environment cause decoherence.</p>
<p>In the <a href="../hamiltonian/">next section</a> we will look specifically at the exact shape of the terms of the Hamiltonian (and when necessary, Lindbladian) used in MuSpinSim.</p>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../theory_1/" class="btn btn-neutral float-left" title="Theory of spin dynamics - I"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../hamiltonian/" class="btn btn-neutral float-right" title="Hamiltonian">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href="../theory_1/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../hamiltonian/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme_extra.js" defer></script>
    <script src="../js/theme.js" defer></script>
      <script src="../js/config.js" defer></script>
      <script src="https://polyfill.io/v3/polyfill.min.js?features=es6" defer></script>
      <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" defer></script>
      <script src="../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
