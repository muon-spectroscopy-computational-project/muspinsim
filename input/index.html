<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../img/favicon.ico" />
    <title>Input - MuSpinSim Documentation</title>
    <link rel="stylesheet" href="../css/theme.css" />
    <link rel="stylesheet" href="../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "Input";
        var mkdocs_page_input_path = "input.md";
        var mkdocs_page_url = null;
      </script>
    
    <script src="../js/jquery-3.6.0.min.js" defer></script>
    <!--[if lt IE 9]>
      <script src="../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
      <script>hljs.initHighlightingOnLoad();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href=".." class="icon icon-home"> MuSpinSim Documentation
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="..">Welcome to MuSpinSim's documentation</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../theory_1/">Theory of spin dynamics - I</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../theory_2/">Theory of spin dynamics - II</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../hamiltonian/">Hamiltonian</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../tutorial/">Tutorial</a>
                </li>
              </ul>
              <ul class="current">
                <li class="toctree-l1 current"><a class="reference internal current" href="./">Input</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#using-expressions-in-keyword-values">Using expressions in keyword values</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#using-multiple-lines-for-a-keyword">Using multiple lines for a keyword</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#input-keywords">Input keywords</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#spins">spins</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#name">name</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#polarization">polarization</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#field">field</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#time">time</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#x_axis">x_axis</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#y_axis">y_axis</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#average_axes">average_axes</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#orientation">orientation</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#temperature">temperature</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#fitting_variables">fitting_variables</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#fitting_data">fitting_data</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#fitting_method">fitting_method</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#fitting_tolerance">fitting_tolerance</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#experiment">experiment</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#zeeman">zeeman</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#hyperfine">hyperfine</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#dipolar">dipolar</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#quadrupolar">quadrupolar</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#dissipation">dissipation</a>
    </li>
        </ul>
    </li>
    </ul>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../examples/">Examples</a>
                </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="..">MuSpinSim Documentation</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href=".." class="icon icon-home" alt="Docs"></a> &raquo;</li>
      <li>Input</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="input">Input</h1>
<p>The input file format for MuSpinSim is a simple text file structured using keywords and values this way:</p>
<pre><code class="language-plaintext">keyword additional arguments
    value_1 
    value_2
</code></pre>
<p>Some keywords accept additional arguments, others don't. Values are on multiple rows; in some cases multiple values can be present on the same row. The most important thing is the indent: values have to be indented with respect to the keywords, if there are no spaces at the beginning of the line then they will be read as another keyword instead. In addition, in some keywords, special functions can be used in place of lengthy lists, as well as operations instead of simple numbers. An example file is the one you can find in <code>/examples/basic/basic.in</code>:</p>
<pre><code class="language-plaintext">name
    basic
spins
    mu e
hyperfine 1
    10   0    0
    0    10   0
    0    0    10
time
    range(0, 0.1, 100)
y_axis
    asymmetry
</code></pre>
<p>This defines a system of a muon and an electron, coupled by an isotropic hyperfine tensor of 10 MHz, and will save a file containing the time evolution of the muon's polarization (asymmetry) from 0 to 0.1 microseconds, in 100 steps.</p>
<h3 id="using-expressions-in-keyword-values">Using expressions in keyword values</h3>
<p>One of the new features of MuSpinSim v1.0.0 is the option to use functions and variables in keyword values. These have a few uses:</p>
<ol>
<li>They can be used to access some meaningful mathematical or physical constants in place of numbers. For example, one can write <code>10.0*MHz</code> as an applied magnetic field, and it will immediately be converted to the equivalent field in Tesla for an ALC resonance, as <code>MHz = 1/(2*muon_gyr)</code>, with the gyromagnetic ratio of the muon, <code>muon_gyr = 135.5388</code> (in MHz/T).</li>
<li>They can be used to generate large ranges of values automatically for some very common use cases. For example, the keyword <code>time</code> stores all the times at which the simulation should be performed. It's a common requirement to want to acquire hundreds or thousands of time points, regularly spaced. One could do this by writing hundreds or thousands of values in column, but it's a lot faster and easier to simply use something like <code>range(0, 1, 100)</code> to create 100 equally spaced time points going from 0 to 1 microseconds.</li>
<li>They can be used to insert variables defined for fitting. For example one might define a hyperfine interaction tensor as a function of two parameters, then fit those parameters to find the optimal tensor that explains an experimental result.</li>
</ol>
<p>Expressions allow use of the operators <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> and <code>^</code> for exponentiation. Parentheses <code>(</code> and <code>)</code> can be used. Strings, if used, must be enclosed in double quotes <code>"</code>.</p>
<p>In the keyword list, below, which constants and functions are allowed for each keyword are specified. User-defined constants are currently not allowed: the only types of user-defined variables that can be used are the ones for fitting. By default, all keywords in which expressions can be used allow the following constants:</p>
<ul>
<li><code>pi</code>: ratio of a circle and its diameter</li>
<li><code>e</code>: base of the natural logarithm</li>
<li><code>deg</code>: conversion factor between radians and degrees, equivalent to <code>180/pi</code></li>
<li><code>inf</code>: infinity</li>
</ul>
<p>and the following functions:</p>
<ul>
<li><code>sin(x)</code>: sine</li>
<li><code>cos(x)</code>: cosine</li>
<li><code>tan(x)</code>: tangent</li>
<li><code>arcsin(x)</code>: inverse of the sine</li>
<li><code>arccos(x)</code>: inverse of the cosine</li>
<li><code>arctan(x)</code>: inverse of the tangent</li>
<li><code>arctan2(y, x)</code>: inverse of the tangent taking two arguments as (sine, cosine) to resolve the quadrant</li>
<li><code>exp(x)</code>: exponential with base e</li>
<li><code>log(x)</code>: natural logarithm</li>
<li><code>sqrt(x)</code>: square root</li>
</ul>
<p>These are all reserved names and can't be used as variable names.</p>
<h3 id="using-multiple-lines-for-a-keyword">Using multiple lines for a keyword</h3>
<p>Some keywords accept an arbitrary amount of lines. This is different from keywords like <code>hyperfine</code>, that only take three lines so that the user can write a full matrix. Keywords that allow multiple rows are meant to allow the user to define ranges of values. When a range of values is defined, three things can happen:</p>
<ol>
<li>one range must always exist and will be specified as the <code>x_axis</code> of the system. This will be the range of values that appears on the first column of the output files. This is usually <code>time</code>, but it can also be, for example, <code>field</code>.</li>
<li>some ranges are specified as <code>average_axes</code> and will be averaged over. This means that calculations will be carried for each value in these ranges and then they will all be summed over, and only the average will be printed out. A typical example of an axis to average over is <code>orientation</code>, to perform powder averages.</li>
<li>any range that isn't specified in the previous two groups automatically means that the software will print out a different file for each value.</li>
</ol>
<p>When using ranges, remember that the number of calculations to perform grows very quickly with them. If one for example asked for an average over 100 different orientations, and to print out a file for each of 20 possible fields and 10 different temperatures, that would result in 100x20x10 = 20,000 individual simulations, and 20x10 = 200 files. The software doesn't have any specific safeguards against going overboard with them, but it's very easy if working on a simple desktop machine or laptop to just overwhelm its capabilities if one uses big ranges carelessly. MuSpinSim is reasonably well optimised and can be very fast for simple calculations, but complex systems and large ranges can make for very resource-intensive simulations.</p>
<p>In the list of input keywords below, keywords that can be defined as a range are identified by the "Allows multiple rows" property.</p>
<h2 id="input-keywords">Input keywords</h2>
<p>Here is a list of accepted keywords and what they mean.</p>
<h3 id="spins">spins</h3>
<table>
<thead>
<tr>
<th>Keyword:</th>
<th align="right"><code>spins</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>Allows multiple rows:</td>
<td align="right">No</td>
</tr>
<tr>
<td>Allows expressions:</td>
<td align="right">No</td>
</tr>
<tr>
<td>Allows constants:</td>
<td align="right">N/A</td>
</tr>
<tr>
<td>Allows functions:</td>
<td align="right">N/A</td>
</tr>
</tbody>
</table>
<p><em>Example:</em></p>
<pre><code class="language-plaintext">spins
    mu e 2H
</code></pre>
<p>A list of the spins to be used in the system. This has to include a muon (<code>mu</code>) and can contain one or more electrons (<code>e</code>). If only one electron is present, it will be the one all hyperfine couplings are with by default. Atomic species refer to the nuclei; so, for example, if you're trying to model the interaction of a muon with a paramagnetic electron on an iron atom, you want to use <code>e</code>, not <code>Fe</code>; the actual spin is that of an electron, not a nucleus! In addition, in case of multiple strongly coupled electrons that can be treated as a single spin greater than 1/2, the isotope syntax can be used too, so for example <code>2e</code> represents two electrons in a triplet state, acting as a single particle with the same gyromagnetic ratio as the electron, but spin 1. The default isotope is the most common one that has a non-zero spin. Other isotopes may be specified by writing the atomic mass as an integer before the symbol. By default, this is a muon and an electron.</p>
<h3 id="name">name</h3>
<table>
<thead>
<tr>
<th>Keyword:</th>
<th align="right"><code>name</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>Allows multiple rows:</td>
<td align="right">No</td>
</tr>
<tr>
<td>Allows expressions:</td>
<td align="right">No</td>
</tr>
<tr>
<td>Allows constants:</td>
<td align="right">N/A</td>
</tr>
<tr>
<td>Allows functions:</td>
<td align="right">N/A</td>
</tr>
</tbody>
</table>
<p><em>Example:</em></p>
<pre><code class="language-plaintext">name
    mysystem
</code></pre>
<p>A prefix to use for all files saved in this simulation. By default it's <code>muspinsim</code>.</p>
<h3 id="polarization">polarization</h3>
<table>
<thead>
<tr>
<th>Keyword:</th>
<th align="right"><code>polarization</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>Allows multiple rows:</td>
<td align="right">Yes</td>
</tr>
<tr>
<td>Allows expressions:</td>
<td align="right">Yes</td>
</tr>
<tr>
<td>Allows constants:</td>
<td align="right">default, <code>longitudinal</code>, <code>transverse</code></td>
</tr>
<tr>
<td>Allows functions:</td>
<td align="right">default</td>
</tr>
</tbody>
</table>
<p><em>Example:</em></p>
<pre><code class="language-plaintext">polarization
    longitudinal
</code></pre>
<p>The direction along which the muon should be polarized when starting, as well as the one in which it will be measured. It can be specified as a vector, and multiple values are allowed. The constants <code>transverse</code> and <code>longitudinal</code> are just useful shorthands for the X axis and the Z axis, respectively. Unless specified otherwise, the magnetic field is aligned along the Z axis. The default value is <code>transverse</code>. </p>
<h3 id="field">field</h3>
<table>
<thead>
<tr>
<th>Keyword:</th>
<th align="right"><code>field</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>Allows multiple rows:</td>
<td align="right">Yes</td>
</tr>
<tr>
<td>Allows expressions:</td>
<td align="right">Yes</td>
</tr>
<tr>
<td>Allows constants:</td>
<td align="right">default, <code>MHz</code>, <code>muon_gyr</code></td>
</tr>
<tr>
<td>Allows functions:</td>
<td align="right">default, <code>range</code></td>
</tr>
</tbody>
</table>
<p><em>Example:</em></p>
<pre><code class="language-plaintext">field
    0
    1*MHz
    2*MHz
    4*MHz
</code></pre>
<p>A single field, or range of magnetic fields, in Tesla, to simulate. These can be scalars or vectors; if scalars, the field will be assumed to be aligned with the Z axis. The function <code>range</code> expands into a number of values - by default, 50 of them, if only the start and end are specified. The default value is zero.</p>
<h3 id="time">time</h3>
<table>
<thead>
<tr>
<th>Keyword:</th>
<th align="right"><code>time</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>Allows multiple rows:</td>
<td align="right">Yes</td>
</tr>
<tr>
<td>Allows expressions:</td>
<td align="right">Yes</td>
</tr>
<tr>
<td>Allows constants:</td>
<td align="right">default</td>
</tr>
<tr>
<td>Allows functions:</td>
<td align="right">default, <code>range</code></td>
</tr>
</tbody>
</table>
<p><em>Example:</em></p>
<pre><code class="language-plaintext">time
    range(0, 1, 100)
</code></pre>
<p>A time or range of times, in microseconds, to simulate. Used by default as the <code>x_axis</code>. The function <code>range</code> expands into a number of values - by default, 50 of them, if only the start and end are specified. The default value is <code>range(0, 10, 101)</code>.</p>
<h3 id="x_axis">x_axis</h3>
<table>
<thead>
<tr>
<th>Keyword:</th>
<th align="right"><code>x_axis</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>Allows multiple rows:</td>
<td align="right">No</td>
</tr>
<tr>
<td>Allows expressions:</td>
<td align="right">No</td>
</tr>
<tr>
<td>Allows constants:</td>
<td align="right">N/A</td>
</tr>
<tr>
<td>Allows functions:</td>
<td align="right">N/A</td>
</tr>
</tbody>
</table>
<p><em>Example:</em></p>
<pre><code class="language-plaintext">x_axis
    field
</code></pre>
<p>Which range to use as the X axis of the simulation's output files. Must be another keyword that accepts a range, and the given keyword <em>must be specified as a range</em> in this input file. When fitting, this is also assumed to be the X axis of the data to fit, and the range specified for this keyword is overridden by the fitting data. By default it's <code>time</code>. </p>
<h3 id="y_axis">y_axis</h3>
<table>
<thead>
<tr>
<th>Keyword:</th>
<th align="right"><code>y_axis</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>Allows multiple rows:</td>
<td align="right">No</td>
</tr>
<tr>
<td>Allows expressions:</td>
<td align="right">No</td>
</tr>
<tr>
<td>Allows constants:</td>
<td align="right">N/A</td>
</tr>
<tr>
<td>Allows functions:</td>
<td align="right">N/A</td>
</tr>
</tbody>
</table>
<p><em>Example:</em></p>
<pre><code class="language-plaintext">y_axis
    integral
</code></pre>
<p>What to save as the Y axis of the simulation's output files: if the muon's polarization (<code>asymmetry</code>) or its integral over time, taking into account the exponential decay with the particle's half-life (<code>integral</code>). By default <code>asymmetry</code>, and can generally be ignored unless one is interested in Avoided Level Crossing experiments, which need <code>integral</code>. When set to <code>integral</code>, the <code>time</code> keyword is ignored and can <em>not</em> be the <code>x_axis</code>.</p>
<h3 id="average_axes">average_axes</h3>
<table>
<thead>
<tr>
<th>Keyword:</th>
<th align="right"><code>average_axes</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>Allows multiple rows:</td>
<td align="right">Yes</td>
</tr>
<tr>
<td>Allows expressions:</td>
<td align="right">No</td>
</tr>
<tr>
<td>Allows constants:</td>
<td align="right">N/A</td>
</tr>
<tr>
<td>Allows functions:</td>
<td align="right">N/A</td>
</tr>
</tbody>
</table>
<p><em>Example:</em></p>
<pre><code class="language-plaintext">average_axes
    orientation
    polarisation
</code></pre>
<p>Any keywords that should have an average carried out over them (if they include a range of values). By default it's just <code>orientation</code>. Any axes with a range that aren't either <code>x_axis</code> or included here are automatically used for different files.</p>
<h3 id="orientation">orientation</h3>
<table>
<thead>
<tr>
<th>Keyword:</th>
<th align="right"><code>orientation</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>Allows multiple rows:</td>
<td align="right">Yes</td>
</tr>
<tr>
<td>Allows expressions:</td>
<td align="right">Yes</td>
</tr>
<tr>
<td>Allows constants:</td>
<td align="right">default</td>
</tr>
<tr>
<td>Allows functions:</td>
<td align="right">default, <code>zcw</code>, <code>eulrange</code></td>
</tr>
</tbody>
</table>
<p><em>Example:</em></p>
<pre><code class="language-plaintext">orientation zxz
    45*deg 0 90*deg 1.0
    90*deg 30*deg 60*deg 2.0
</code></pre>
<p>One or more orientations to use for the crystallites making up the system. Used to define powder averages. The rows can come in a number of ways:</p>
<ul>
<li>two numbers are interpreted as two polar angles θ and ϕ, defining only the direction of the Z axis of the new system. This setting is recommended only for powder averages in which only the Z axis matters; typical example is an ALC calculation with both the magnetic field and the muon polarization aligned along Z.</li>
<li>three numbers are interpreted as Euler angles defining a new frame. If there is no argument specified after <code>orientation</code>, the convention used is ZYZ. As seen in the example, it's possible to specify it to be ZXZ instead.</li>
<li>four numbers are interpreted as Euler angles as above, plus one weight. The weights don't need to add up to one (they will be normalised). In this case, any average over these orientations will be weighted; otherwise, the weights will be ignored.</li>
</ul>
<p>Two helper functions are provided to generate automatically ranges of orientations for powder averages. <code>zcw(N)</code> creates N or more polar angle pairs using the Zaremba-Conroy-Wolfsberg algorithm to cover the sphere. It's cheap but only usable in cases in which polar angles are sufficient. <code>eulrange(N)</code> creates a regular grid of <span class="arithmatex">\(N\times N \times N\)</span> Euler angles with appropriate weights. This covers the space of all possible orientations in 3D but can become a lot more expensive very quickly.</p>
<h3 id="temperature">temperature</h3>
<table>
<thead>
<tr>
<th>Keyword:</th>
<th align="right"><code>temperature</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>Allows multiple rows:</td>
<td align="right">Yes</td>
</tr>
<tr>
<td>Allows expressions:</td>
<td align="right">Yes</td>
</tr>
<tr>
<td>Allows constants:</td>
<td align="right">default</td>
</tr>
<tr>
<td>Allows functions:</td>
<td align="right">default, <code>range</code></td>
</tr>
<tr>
<td><em>Example:</em></td>
<td align="right"></td>
</tr>
</tbody>
</table>
<pre><code class="language-plaintext">temperature
    273.0
</code></pre>
<p>Temperature in Kelvin of the system. This is used to determine the initial density matrix of the system, as every spin that is not the muon is put in a thermal state, and in case of dissipative systems, to determine the coupling to the thermal bath. By default, it is set to infinity. A warning: both density matrices and dissipative couplings for finite temperatures are only calculated approximatively, based on the individual Hamiltonians for each spin which only account for the applied magnetic field. In other words, these approximations are meant for high field experiments, and break down in the low field regime. Therefore, caution should be used when changing this variable or interpreting the resulting simulations.</p>
<h3 id="fitting_variables">fitting_variables</h3>
<table>
<thead>
<tr>
<th>Keyword:</th>
<th align="right"><code>fitting_variables</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>Allows multiple rows:</td>
<td align="right">Yes</td>
</tr>
<tr>
<td>Allows expressions:</td>
<td align="right">Yes</td>
</tr>
<tr>
<td>Allows constants:</td>
<td align="right">default, <code>muon_gyr</code>, <code>MHz</code></td>
</tr>
<tr>
<td>Allows functions:</td>
<td align="right">default</td>
</tr>
</tbody>
</table>
<p><em>Example:</em></p>
<pre><code class="language-plaintext">fitting_variables
    x
    y  1.0  0.0 5.0
</code></pre>
<p>Variables to fit to the experimental data. If present, the calculation is assumed to be a fitting, and the <code>fitting_data</code> keyword must be present too. The first letter in each row is the name of the variable; optionally, it can be followed in order by the starting value of the variable, the minimum bound, and the maximum bound (by default <code>0</code>, <code>-inf</code> and <code>+inf</code>). It is important to notice that while expressions are accepted in the definition of value, minimum, and maximum, these can not contain the name of other variables.</p>
<h3 id="fitting_data">fitting_data</h3>
<table>
<thead>
<tr>
<th>Keyword:</th>
<th align="right"><code>fitting_data</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>Allows multiple rows:</td>
<td align="right">Yes</td>
</tr>
<tr>
<td>Allows expressions:</td>
<td align="right">Yes</td>
</tr>
<tr>
<td>Allows constants:</td>
<td align="right">none</td>
</tr>
<tr>
<td>Allows functions:</td>
<td align="right"><code>load</code></td>
</tr>
</tbody>
</table>
<p><em>Example:</em></p>
<pre><code class="language-plaintext">fitting_data
    load('results.dat')
</code></pre>
<p>Block of data to fit. Must have two columns: the first one is the <code>x_axis</code> (for example, time), while the second is the expected result of the simulation. The function <code>load</code> can be used to load it from an ASCII tabulated file on disk, as long as it has only two columns. Note that the data must be normalized properly to match the conventions of MuSpinSim's output, so for example it must start from 0.5 at t = 0 (as that's the moment of the muon before it has had any time to evolve).</p>
<h3 id="fitting_method">fitting_method</h3>
<table>
<thead>
<tr>
<th>Keyword:</th>
<th align="right"><code>fitting_method</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>Allows multiple rows:</td>
<td align="right">No</td>
</tr>
<tr>
<td>Allows expressions:</td>
<td align="right">No</td>
</tr>
<tr>
<td>Allows constants:</td>
<td align="right">N/A</td>
</tr>
<tr>
<td>Allows functions:</td>
<td align="right">N/A</td>
</tr>
<tr>
<td><em>Example:</em></td>
<td align="right"></td>
</tr>
</tbody>
</table>
<pre><code class="language-plaintext">fitting_method
    lbfgs
</code></pre>
<p>Method to use to fit the data. Currently available are only <code>nelder-mead</code> (default) and <code>lbfgs</code>.</p>
<h3 id="fitting_tolerance">fitting_tolerance</h3>
<table>
<thead>
<tr>
<th>Keyword:</th>
<th align="right"><code>fitting_tolerance</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>Allows multiple rows:</td>
<td align="right">No</td>
</tr>
<tr>
<td>Allows expressions:</td>
<td align="right">No</td>
</tr>
<tr>
<td>Allows constants:</td>
<td align="right">N/A</td>
</tr>
<tr>
<td>Allows functions:</td>
<td align="right">N/A</td>
</tr>
</tbody>
</table>
<p><em>Example:</em></p>
<pre><code class="language-plaintext">fitting_tolerance
    1e-4
</code></pre>
<p>Tolerance for the fitting. Used as the <code>tol</code> parameter in Scipy's <code>scipy.optimize.minimize</code> method; exact meaning depends on fitting method. Check the <a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize.html">Scipy documentation</a> for further details.</p>
<h3 id="experiment">experiment</h3>
<table>
<thead>
<tr>
<th>Keyword:</th>
<th align="right"><code>experiment</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>Allows multiple rows:</td>
<td align="right">No</td>
</tr>
<tr>
<td>Allows expressions:</td>
<td align="right">No</td>
</tr>
<tr>
<td>Allows constants:</td>
<td align="right">N/A</td>
</tr>
<tr>
<td>Allows functions:</td>
<td align="right">N/A</td>
</tr>
</tbody>
</table>
<p><em>Example:</em></p>
<pre><code class="language-plaintext">experiment
    alc
</code></pre>
<p>A convenience keyword that sets a number of other parameters to reproduce certain experimental setups. Possible values are <code>alc</code> (sets up an Avoided Level Crossing experiment: longitudinal polarization, <code>field</code> as <code>x_axis</code>, <code>integral</code> as <code>y_axis</code>) and <code>zero_field</code> (sets <code>field</code> as 0 and <code>polarization</code> as <code>transverse</code>).</p>
<h3 id="zeeman">zeeman</h3>
<table>
<thead>
<tr>
<th>Keyword:</th>
<th align="right"><code>zeeman</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>Allows multiple rows:</td>
<td align="right">No</td>
</tr>
<tr>
<td>Allows expressions:</td>
<td align="right">Yes</td>
</tr>
<tr>
<td>Allows constants:</td>
<td align="right">Default</td>
</tr>
<tr>
<td>Allows functions:</td>
<td align="right">Default</td>
</tr>
</tbody>
</table>
<p><em>Example:</em></p>
<pre><code class="language-plaintext">zeeman 1
    2.0 2.0 0
</code></pre>
<p>Add a Zeeman coupling term specifying a local magnetic field, in Tesla, for a given spin. This coupling will be on top of the standard coupling with the external magnetic field from the laboratory, that always applies to all spins. The argument is the index of the coupled spin. Indices count from 1.</p>
<h3 id="hyperfine">hyperfine</h3>
<table>
<thead>
<tr>
<th>Keyword:</th>
<th align="right"><code>hyperfine</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>Allows multiple rows:</td>
<td align="right">No</td>
</tr>
<tr>
<td>Allows expressions:</td>
<td align="right">Yes</td>
</tr>
<tr>
<td>Allows constants:</td>
<td align="right">Default</td>
</tr>
<tr>
<td>Allows functions:</td>
<td align="right">Default</td>
</tr>
</tbody>
</table>
<p><em>Example:</em></p>
<pre><code class="language-plaintext">hyperfine 1
    100 10  10
    10  100 10
    10  10  100
</code></pre>
<p>Specify a hyperfine tensor, in MHz, for a given spin. A hyperfine tensor couples the spin with one electron in the system. If there is only one electron, then only one index can be indicated, and it's the index of the non-electron spin. If there is more than one electron in the system, more than one index must be indicated, and the second index must refer to an electron. The tensor must be written with three numbers per line. The argument (here <code>1</code>) represents the index of the coupled spin. A second argument specifying the index of the electron is only obligatory if the system has more than one electron. Indices count from 1. Note that the block is always composed of three rows, but this is not interpreted as a range.</p>
<h3 id="dipolar">dipolar</h3>
<table>
<thead>
<tr>
<th>Keyword:</th>
<th align="right"><code>dipolar</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>Allows multiple rows:</td>
<td align="right">No</td>
</tr>
<tr>
<td>Allows expressions:</td>
<td align="right">Yes</td>
</tr>
<tr>
<td>Allows constants:</td>
<td align="right">Default</td>
</tr>
<tr>
<td>Allows functions:</td>
<td align="right">Default</td>
</tr>
<tr>
<td><em>Example:</em></td>
<td align="right"></td>
</tr>
</tbody>
</table>
<pre><code class="language-plaintext">dipolar 1 2
    0   1   1
</code></pre>
<p>Specify a dipolar coupling between two spins. This is given by a vector connecting them, in Angstrom. The coupling tensor will be then calculated based on the known gyromagnetic ratios of those spins. The two arguments are the indices of the coupled spins. Indices count from 1.</p>
<h3 id="quadrupolar">quadrupolar</h3>
<table>
<thead>
<tr>
<th>Keyword:</th>
<th align="right"><code>quadrupolar</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>Allows multiple rows:</td>
<td align="right">No</td>
</tr>
<tr>
<td>Allows expressions:</td>
<td align="right">Yes</td>
</tr>
<tr>
<td>Allows constants:</td>
<td align="right">Default</td>
</tr>
<tr>
<td>Allows functions:</td>
<td align="right">Default</td>
</tr>
</tbody>
</table>
<p><em>Example:</em></p>
<pre><code class="language-plaintext">quadrupolar 3
    100 10  10
    10  100 10
    10  10  -200
</code></pre>
<p>Specify a quadrupolar coupling for a spin by using an Electric Field Gradient tensor in atomic units (as returned by for example the DFT software CASTEP). The argument is the index of the spin. The coupling will then be calculated by using the known values of angular momentum and quadrupole moment for each spin. Spins with zero quadrupole moment (like hydrogen) will have zero coupling regardless of what is specified in this term. Indices count from 1. Note that the block is always composed of three rows, but this is not interpreted as a range.</p>
<h3 id="dissipation">dissipation</h3>
<table>
<thead>
<tr>
<th>Keyword:</th>
<th align="right"><code>dissipation</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>Allows multiple rows:</td>
<td align="right">No</td>
</tr>
<tr>
<td>Allows expressions:</td>
<td align="right">Yes</td>
</tr>
<tr>
<td>Allows constants:</td>
<td align="right">Default</td>
</tr>
<tr>
<td>Allows functions:</td>
<td align="right">Default</td>
</tr>
</tbody>
</table>
<p><em>Example:</em></p>
<pre><code class="language-plaintext">dissipation 1
    0.5
</code></pre>
<p>Add a dissipation term for a given spin, which switches the system to using the <a href="../theory_2/#the-lindblad-master-equation">Lindblad master equation</a> instead of regular unitary quantim evolution. The dissipative term will cause random spin flips that decohere the system and drive it towards a thermal equilibrium state (determined by the temperature). The dissipation term is given in MHz. Indices count from 1. </p>
<blockquote>
<p><strong>CAUTION:</strong> Lindbladian matrices can be not diagonalizable. This functionality does not yet account for that, so it could fail in some cases.</p>
</blockquote>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../tutorial/" class="btn btn-neutral float-left" title="Tutorial"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../examples/" class="btn btn-neutral float-right" title="Examples">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href="../tutorial/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../examples/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme_extra.js" defer></script>
    <script src="../js/theme.js" defer></script>
      <script src="../js/config.js" defer></script>
      <script src="https://polyfill.io/v3/polyfill.min.js?features=es6" defer></script>
      <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" defer></script>
      <script src="../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
